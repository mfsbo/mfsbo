---
title: Development in year 2024
description: ""
date: 2024-12-23T01:01:41.600Z
preview: ""
tags: []
categories: []
type: default
---
At end of 2024 I have been dominantly working in front end however have touch based on backend in .net 8/9 along with Azure and AWS clouds.

Working with Vue 3, Angular and React, I feel Vue is still most easy to start and understand the concepts of front end modular development. Had a little hard time explaining why we need .vue files and a development pipeline with typescript however I have found a compile time error check is way better than runtime error check. Once hit by runtime errors its better to struggle and understand the compile time checking at least for undefined or object shapes.

Few teams I have spoken with have dealt with git modules, monorepo including .net with nx and keeping api's in aspire but having frontend monorepo. For last few years and entering 2025 I feel like the flexibility to keep backend and front end separate with many choices in both is such a good thing for teams. However this can be problematic if clear boundary is not defined. It can work with 2 people team or 5 teams of 6 people each team. From UI/UX mockups to Development of MVPs and Release to Live the software aim is to deliver a feature. During the process if the code is telling an easy story then no need to add unnecessary complexity. If the code is telling a complex story then it is time to refactor and make it easy to understand. This is the only way to keep the software maintainable and easy to work with. 

Refactor is another challenge where I have worked with this year while building new features. For example API's that use Open AI should be written such that a new model introduced by Open AI require minimum change to add it and as OpenAI or chatGPT is keeping the same interfaces you should be able to update via config or minimum change in code. Similarly I have worked with Cloudinary as a image manager. In both cases without even knowing the rest of application the abstraction of these two as providers of ai and image management should be easy to understand and use.Having an image manager which then have implementation of cloudinary or any other image manager should be easy to switch. Similarly having OpenAI 3.5 or 4.0 should be easy to switch. This is the challenge. A refactor at start of 2024 allowed me to move to recent model and updated cloudinary schemes as we go along. Love the way .net abstractions are for example for EF Core and Testing. It was easy to switch to .net 9 from .net 7.

I was able to manage Continuous delivery using aspire, gulp and node, powershell and few yaml. The painful point was debugging github actions otherwise with little help from AI I was able to take way old methods and convert them to equivalent modern methods. Keeping in mind the ability of teams and their needs I was able to modify things where juniors can even contribute and see the action failed and modify their PRs with zero interventions from seniors. I try to stay away from any solid performance measures however delivery to customer is definitely one of the biggest output where businesses and developers both have full attention. In 2024 any project I have worked on the delivery to customer has been 200% or more than what it was in 2023. I was lucky to work with people who listened from start and we were able to achiever quicker deployments in many systems. 

I love the way .net Aspire and Laravel has open telemetry backed in. The effort to setup services and telemetry has reduced so much in 2024 that there is no excuse to not start with it. If you are planning to have only one service even then you will see the benefit of capturing all that data, with couple of lines from day 0, is way more than the effort to setup. I have seen the benefit of this in many projects where we were able to see the performance of the system and where we need to improve. Sometimes this is enough for both juniors and seniors to understand the system and where it is going as you develop. In some cases it has helped them identify pull requests that have caused performance improvements or degradation.

Semver with Node npm version patch and post hooks had been great to work with. AI with copilot or github CLI was great to help and pickup PRs merged in to create release notes for a particular version. Powershell and Gulp has helped introduce global or internal variables for versioning which can then update API versions or UI/UX library versions within files on CDN etc. Some of these concepts are there for long time however implementing them together to achieve a solid CI/CD pipeline with versioning is a challenge. 2024 has seen AI resolve this challenge with ease. This is also one of the factor in enhancing release notes quality.
